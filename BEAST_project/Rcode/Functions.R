# Functions to analyze log files generated by BEAST2

g_legend<-function(a.gplot){
  tmp <- ggplot_gtable(ggplot_build(a.gplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)}

create_subFig <- function(selection_type='Neutral', n=20, M, pop_size=100, measure='migration', method='absolute',
                          xlabel = "Simulated migration rate", ylabel = "Estimated migration rate", ylimit=c(0,0.03),
                          data = 'original_2', folder = 'P100_forPaper_flexpop', full = TRUE){

  # WITH TREE 
  # Create matrix of logFile names and matrixes for saving data ####
  logfilenames_with = matrix(0,
                             nrow = length(M),
                             ncol = n,
                             byrow = FALSE)
  logfilenames_without = matrix(0,
                                nrow = length(M),
                                ncol = n,
                                byrow = FALSE)
  
  ############ neutral results #####
  log_all_neutral_with <- data.frame(matrix(ncol = 5, nrow = 0))
  names(log_all_neutral_with) = c("traitClockRate","real_mig","tree_status","x_axis",'treeStatus')       
  
  log_all_neutral_without <- data.frame(matrix(ncol = 5 , nrow = 0))
  names(log_all_neutral_without) = c("traitClockRate","real_mig","tree_status","x_axis",'treeStatus') 
  
  means_neutral_with <- matrix(ncol=n, nrow = length(M))
  var_neutral_with <- matrix(ncol=n, nrow = length(M))
  means_neutral_without <- matrix(ncol=n, nrow = length(M))
  var_neutral_without <- matrix(ncol=n, nrow = length(M))
  
  for (i in 1:length(M)){
    for (j in 1:n){
      logfilenames_without[i,j] = paste('/users/judith/polybox/BEAST_project/',folder,'/Lemey_',selection_type,'_',data,'_m',M[i],'n',j-1,'P',pop_size,'.log',sep="")
      
      # Read data from file -- lemey type
      log_tot_without = read.table(logfilenames_without[i,j], header=TRUE, fill = TRUE)
      
      # Remove first 10 %
      log_trim_without = log_tot_without[((dim(log_tot_without)[1]-1)/10+1):dim(log_tot_without)[1],]
      log_trim_frame_without = as.data.frame(log_trim_without)
      log_trim_frame_without["real_mig"] <- rep(as.numeric(M[i]),dim(log_trim_without)[1])
      
      log_trim_frame_without["treeStatus"]<- rep(0,dim(log_trim_frame_without)[1])
      log_trim_frame_without <- log_trim_frame_without %>% mutate(x_axis = as.factor(as.numeric(factor(real_mig))*100 + 10*treeStatus))
      
      levels(log_trim_frame_without$x_axis)<- paste(M[i],'b',sep='')
      
      # calculate relative difference between refered and real migration rate
      if (measure == 'migration' ){
        if (method == 'absolute'){
          log_trim_frame_without["rel"] <- (log_trim_frame_without$traitClockRate )
        } else {
          log_trim_frame_without["rel"] <- (log_trim_frame_without$traitClockRate - log_trim_frame_without$real_mig)/log_trim_frame_without$real_mig
        }
      } else if (measure == 'tree'){
        log_trim_frame_without["rel"] <- log_trim_frame_without$popSize
      } else if (measure == 'mut'){
        log_trim_frame_without["rel"] <- log_trim_frame_without$rateStat.Scenario_1.mean
      }
      
      
      means_neutral_without[i,j] <- mean(log_trim_frame_without$rel)
      var_neutral_without[i,j] <- var(log_trim_frame_without$rel)
      
      
      # combine two data frames
      log_all_neutral_without_final <- cbind(log_trim_frame_without$rel, log_trim_frame_without$real_mig, 
                                             log_trim_frame_without$treeStatus, log_trim_frame_without$x_axis) 
      log_all_neutral_without <- rbind(log_all_neutral_without,log_all_neutral_without_final)
    }
  }
  
  names(log_all_neutral_without) <- c('traitClockRate','real_mig','treeStatus','x_axis')
  error_neutral_without <- data.frame(matrix(ncol = 4 , nrow = length(M)))
  names(error_neutral_without) = c("mean","sd","upper","lower")
  error_neutral_without["real_mig"]=as.factor(M)
  
  for (i in 1:length(M) ){
    y = log_all_neutral_without$traitClockRate[log_all_neutral_without$real_mig==as.numeric(M[i])]
    error_neutral_without[i,1] = median(y)
    error_neutral_without[i,2] = sd(y)
    error_neutral_without[i,3] = sort(y)[round(length(y)/100*95)]
    error_neutral_without[i,4] = sort(y)[round(length(y)/100*5)]
  }
  
  #Melting data neutral
  M2_neutral <- melt(log_all_neutral_without,id.vars= 2, measure.vars= 1 )
  M2_neutral$treeStatus <- log_all_neutral_without[,3]
  M2_neutral <- M2_neutral %>% mutate(x_axis = as.factor(as.numeric(factor(real_mig))*100 + 10*treeStatus))
  levels(M2_neutral$x_axis)<- paste(M,'b',sep='')
  
  M2_neutral$real_mig <- as.factor(M2_neutral$real_mig)
  M2_neutral['mig'] <- as.numeric(M2_neutral$real_mig)/1000
  
  error_neutral_without$x_axis <- levels(M2_neutral$x_axis)
  
  if (full){
    for (i in 1:length(M)){
      for (j in 1:n){
        logfilenames_with[i,j] = paste('/users/judith/polybox/BEAST_project/',folder,'/Lemey_',selection_type,'_with_',data,'_m',M[i],'n',j-1,'P',pop_size,'.log',sep="")
        
        # Read data from file -- lemey type
        log_tot_with = read.table(logfilenames_with[i,j], header=TRUE, fill = TRUE)
        
        # Remove first 10 %
        log_trim_with = log_tot_with[((dim(log_tot_with)[1]-1)/10+1):dim(log_tot_with)[1],]
        log_trim_frame_with = as.data.frame(log_trim_with)
        log_trim_frame_with["real_mig"] <- rep(as.numeric(M[i]),dim(log_trim_with)[1])
        
        log_trim_frame_with["treeStatus"] <- rep(1,dim(log_trim_frame_with)[1])
        log_trim_frame_with <- log_trim_frame_with %>% mutate(x_axis = as.factor(as.numeric(factor(real_mig))*100 + 10*treeStatus))
        
        levels(log_trim_frame_with$x_axis)<- paste(M[i],'a',sep='')
        
        # calculate relative difference between referred and real migration rate
        if (measure == 'migration' ){
          if (method == 'absolute'){
            log_trim_frame_with["rel"] <- log_trim_frame_with$traitClockRate
          } else {
            log_trim_frame_with["rel"] <- (log_trim_frame_with$traitClockRate - log_trim_frame_with$real_mig)/log_trim_frame_with$real_mig
          }
        } else if (measure == 'tree'){
          log_trim_frame_with["rel"] <- log_trim_frame_with$popSize
        } else if (measure == 'mut'){
          log_trim_frame_with["rel"] <- log_trim_frame_with$rateStat.Scenario_1.mean
        }
        
        
        means_neutral_with[i,j] <- mean(log_trim_frame_with$rel)
        var_neutral_with[i,j] <- var(log_trim_frame_with$rel)
        
        # combine two data frames
        log_all_neutral_with_final <- cbind(log_trim_frame_with$rel, log_trim_frame_with$real_mig, 
                                            log_trim_frame_with$treeStatus, log_trim_frame_with$x_axis)

        log_all_neutral_with <- rbind(log_all_neutral_with,log_all_neutral_with_final)
      }
    }
    
    names(log_all_neutral_with) <- c('traitClockRate','real_mig','treeStatus','x_axis')
    error_neutral_with <- data.frame(matrix(ncol = 4 , nrow = length(M)))
    names(error_neutral_with) = c("mean","sd","upper","lower")
    error_neutral_with["real_mig"]=as.factor(M)
    
    for (i in 1:length(M) ){
      x = log_all_neutral_with$traitClockRate[log_all_neutral_with$real_mig==as.numeric(M[i])]
      error_neutral_with[i,1] = median(x)
      error_neutral_with[i,2] = sd(x)
      error_neutral_with[i,3] = sort(x)[round(length(x)/100*95)]
      error_neutral_with[i,4] = sort(x)[round(length(x)/100*5)]
    }
    
    #Melting data neutral
    M1_neutral <- melt(log_all_neutral_with[,1:2],id.vars= 'real_mig', variable.name = 'traitClockRate')
    M1_neutral$treeStatus <- log_all_neutral_with[,3]
    M1_neutral <- M1_neutral %>% mutate(x_axis = as.factor(as.numeric(factor(real_mig))*100 + 10*treeStatus))
    levels(M1_neutral$x_axis)<- paste(M,'a',sep='')
    
    M1_neutral$real_mig <- as.factor(M1_neutral$real_mig)
    M1_neutral['mig'] <- as.numeric(M1_neutral$real_mig)/1000
    
    error_neutral_with$x_axis <- levels(M1_neutral$x_axis)
    
  }
  

if (full){
  basis <- data.frame(matrix(ncol = 4 , nrow = 2*length(M)))
  names(basis) = c("traitClockRate","real_mig","tree_status","x_axis")    
  basis['traitClockRate']=as.numeric(c('0.001','0.001', '0.002', '0.002','0.003','0.003', '0.004', '0.004', '0.005', '0.005','0.006','0.006', '0.007', '0.007','0.008','0.008','0.009','0.009','0.01','0.01'))
  basis['real_mig']=as.numeric(c('0.001','0.001', '0.002', '0.002','0.003','0.003', '0.004', '0.004', '0.005', '0.005','0.006','0.006', '0.007', '0.007','0.008','0.008','0.009','0.009','0.01','0.01'))
  basis['x_axis']=c('0.001a','0.001b', '0.002a', '0.002b','0.003a','0.003b', '0.004a', '0.004b', '0.005a', '0.005b','0.006a','0.006b', '0.007a', '0.007b','0.008a','0.008b','0.009a','0.009b','0.01a','0.01b')
  
  basis.M <- melt(basis[,1:2],id.vars= 'real_mig', variable.name = 'traitClockRate')
  basis.M$real_mig <- as.factor(basis.M$real_mig)
  
  # Create Figure
  if (measure == 'migration') {
    een = as.numeric(c(rep(0.001,2), rep(0.002,2),rep(0.003,2),rep(0.004,2),rep(0.005,2),rep(0.006,2),rep(0.007,2),rep(0.008,2),rep(0.009,2),rep(0.01,2)))
  } else if (measure == 'tree'){
    een = rep(200, length(M)*2)
  } else if (measure == 'mut'){
    een = rep(2.16e-4, length(M)*2)
  }
  
  drie = c('0.001a','0.001b', '0.002a', '0.002b','0.003a','0.003b', '0.004a', '0.004b', '0.005a', '0.005b','0.006a','0.006b', '0.007a', '0.007b','0.008a','0.008b','0.009a','0.009b','0.01a','0.01b')
  true.rates = as.data.frame(cbind(een,drie))
  true.rates$een <- as.numeric(true.rates$een)
  
  p1 =  
    ggplot() +
    geom_violin(data=M1_neutral, aes(x = x_axis, y = value),colour="#1A2C56", fill="#1A2C56", alpha = .2, size=0.3) +
    geom_violin(data=M2_neutral, aes(x = x_axis, y = value),colour="#D1A683",fill="#D1A683", alpha = .2, size=0.3) +
    xlab(xlabel)+ ylab(ylabel) + ylim(ylimit) +
    ggtitle(selection_type) + 
    stat_summary(data=error_neutral_with,aes(x = x_axis, y = mean,colour="Using true genealogy"), geom="point", size=3) +
    stat_summary(data=error_neutral_without,aes(x = x_axis, y = mean,colour="Using sequence data"), geom="point", size=3) +
    geom_errorbar(data=error_neutral_with,aes(x=x_axis, ymax=upper, ymin=lower),colour="#1A2C56",size=2) +
    geom_errorbar(data=error_neutral_without,aes(x=x_axis, ymax=upper, ymin=lower),size=2,colour="#D1A683") +
    theme(axis.text = element_text(size=18),axis.title = element_text(size=24), text = element_text(size=24),legend.position="bottom", 
          panel.grid.major =element_line(colour = "grey"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
          legend.key=element_blank(), legend.background = element_blank()) +
    geom_point(data = true.rates, aes(x=drie, y = een), col = 'red') + 
    scale_x_discrete( labels= c('0.001','', '0.002', '','0.003','', '0.004', '', '0.005', '','0.006','', '0.007', '','0.008','', '0.009','','0.01','') )+
    scale_colour_manual("", values=c("Using True Genealogy" = "#1A2C56", "Using sequence data" ="#D1A683")) 
} else {
  basis <- data.frame(matrix(ncol = 4 , nrow = length(M)))
  names(basis) = c("traitClockRate","real_mig","tree_status","x_axis")    
  basis['traitClockRate']=seq(0.001, 0.01, 0.001)
  basis['real_mig']=seq(0.001, 0.01, 0.001)
  basis['x_axis']=seq(0.001, 0.01, 0.001)
  
  basis.M <- melt(basis[,1:2],id.vars= 'real_mig', variable.name = 'traitClockRate')
  basis.M$real_mig <- as.factor(basis.M$real_mig)
  
  # Create Figure
  if (measure == 'migration') {
    een = seq(0.001, 0.01, 0.001)
  } else if (measure == 'tree'){
    een = rep(200, length(M))
  } else if (measure == 'mut'){
    een = rep(2.16e-4, length(M))
  }
  
  drie = seq(0.001, 0.01, 0.001)
  true.rates = as.data.frame(cbind(een,drie))
  true.rates$een <- as.numeric(true.rates$een)
  
  p1 =  
    ggplot() +
    geom_violin(data=M2_neutral, aes(x = x_axis, y = value),colour="#D1A683",fill="#D1A683", alpha = .2, size=0.3) +
    xlab(xlabel)+ ylab(ylabel) + ylim(ylimit) +
    ggtitle(selection_type) + 
    stat_summary(data=error_neutral_without,aes(x = x_axis, y = mean,colour="Using sequence data"), geom="point", size=3) +
    geom_errorbar(data=error_neutral_without,aes(x=x_axis, ymax=upper, ymin=lower),size=2,colour="#D1A683") +
    theme(axis.text = element_text(size=18),axis.title = element_text(size=24), text = element_text(size=24),legend.position="bottom", 
          panel.grid.major =element_line(colour = "grey"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
          legend.key=element_blank(), legend.background = element_blank()) +
    geom_hline(yintercept = een[1], col = 'red') + 
    scale_x_discrete( labels= c('0.001', '0.002','0.003', '0.004', '0.005','0.006', '0.007','0.008','0.009','0.01') )+
    scale_colour_manual("", values=c("Using sequence data" ="#D1A683")) 
}

  if (full){
    return(list(p1, error_neutral_with, error_neutral_without, means_neutral_with, means_neutral_without))
  } else {
    return(list(p1,  error_neutral_without, means_neutral_without))
  }

}


create_sig_fig <- function(means_neutral_with, means_neutral_without,
                           means_MFED_with,means_MFED_without,
                           means_CTL_with,means_CTL_without,
                           means_CTL_MFED_with,means_CTL_MFED_without, m=seq(0.001,0.01,0.001), n =15, compare=seq(0.001,0.01,0.001)){
  
  test_0_neutral_with <- vector("numeric", length(M))
  test_0_neutral_without <- vector("numeric", length(M))
  
  for (i in 1:length(m)){
    test_0_neutral_with[i] = binom.test(sum(means_neutral_with[i,]-compare[i]>0),n,0.5)$p.value
    test_0_neutral_without[i] = binom.test(sum(means_neutral_without[i,]-compare[i]>0),n,0.5)$p.value
  }
  
  test_0_CTL_MFED_with <- vector("numeric", length(M))
  test_0_CTL_MFED_without <- vector("numeric", length(M))
  
  for (i in 1:length(m)){
    test_0_CTL_MFED_with[i] = binom.test(sum(means_CTL_MFED_with[i,]-compare[i]>0),n,0.5)$p.value
    test_0_CTL_MFED_without[i] = binom.test(sum(means_CTL_MFED_without[i,]-compare[i]>0),n,0.5)$p.value
  }
  
  test_0_MFED_with <- vector("numeric", length(M))
  test_0_MFED_without <- vector("numeric", length(M))
  
  for (i in 1:length(m)){
    test_0_MFED_with[i] = binom.test(sum(means_MFED_with[i,]-compare[i]>0),n,0.5)$p.value
    test_0_MFED_without[i] = binom.test(sum(means_MFED_without[i,]-compare[i]>0),n,0.5)$p.value
  }
  
  test_0_CTL_with <- vector("numeric", length(M))
  test_0_CTL_without <- vector("numeric", length(M))
  
  for (i in 1:length(m)){
    test_0_CTL_with[i] = binom.test(sum(means_CTL_with[i,]-compare[i]>0),n,0.5)$p.value
    test_0_CTL_without[i] = binom.test(sum(means_CTL_without[i,]-compare[i]>0),n,0.5)$p.value
  }
  
  test_0_neutral_with.df <- as.data.frame(as.matrix(x=cbind(m,test_0_neutral_with)))
  test_0_neutral_without.df <- as.data.frame(as.matrix(x=cbind(m,test_0_neutral_without)))
  
  test_0_MFED_with.df <- as.data.frame(as.matrix(x=cbind(m,test_0_MFED_with)))
  test_0_MFED_without.df <- as.data.frame(as.matrix(x=cbind(m,test_0_MFED_without)))
  
  test_0_CTL_with.df <- as.data.frame(as.matrix(x=cbind(m,test_0_CTL_with)))
  test_0_CTL_without.df <- as.data.frame(as.matrix(x=cbind(m,test_0_CTL_without)))
  
  test_0_CTL_MFED_with.df <- as.data.frame(as.matrix(x=cbind(m,test_0_CTL_MFED_with)))
  test_0_CTL_MFED_without.df <- as.data.frame(as.matrix(x=cbind(m,test_0_CTL_MFED_without)))
  
  p2_A <- ggplot() + 
    geom_rect(mapping=aes(xmin=0, xmax=0.01, ymin=1e-6, ymax=0.005, fill=TRUE), color=NA, fill='red', alpha=0.2) +
    geom_point(data = test_0_neutral_with.df , aes(x=m, y = test_0_neutral_with), colour="#1A2C56") +
    geom_point(data = test_0_neutral_without.df , aes(x=m, y = test_0_neutral_without), colour="#D1A683") +
    xlab("Simulated migration rate")+ ylab("P-value binomial test for bias") + ggtitle("Neutral") +
    theme(axis.text = element_text(size=18),axis.title = element_text(size=24), text = element_text(size=24),legend.position="bottom", 
          panel.grid.major =element_line(colour = "grey"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
          legend.key=element_blank(), legend.background = element_blank())+
    scale_y_continuous(trans = 'log10', limits = c(1e-6,1)) +
    scale_x_continuous( breaks = seq(0.001,0.01,0.001) ) + 
    scale_colour_manual("", values=c("Using True Genealogy" = "#1A2C56","Using sequence data" ="#D1A683"))
  
  p2_B <- ggplot() + 
    geom_rect(mapping=aes(xmin=0, xmax=0.01, ymin=1e-6, ymax=0.005, fill=TRUE), color=NA, fill='red', alpha=0.2) +
    geom_point(data = test_0_MFED_with.df , aes(x=m, y = test_0_MFED_with), colour="#1A2C56") +
    geom_point(data = test_0_MFED_without.df , aes(x=m, y = test_0_MFED_without), colour="#D1A683") +
    xlab("Simulated migration rate")+ ylab("P-value binomial test for bias") + ggtitle("MFED") +
    theme(axis.text = element_text(size=18),axis.title = element_text(size=24), text = element_text(size=24),legend.position="bottom", 
          panel.grid.major =element_line(colour = "grey"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
          legend.key=element_blank(), legend.background = element_blank())+
    scale_y_continuous(trans = 'log10', limits = c(1e-6,1)) +
    scale_x_continuous( breaks = seq(0.001,0.01,0.001) ) + 
    scale_colour_manual("", values=c("Using True Genealogy" = "#1A2C56","Using sequence data" ="#D1A683"))
  
  p2_C <- ggplot() + 
    geom_rect(mapping=aes(xmin=0, xmax=0.01, ymin=1e-6, ymax=0.005, fill=TRUE), color=NA, fill='red', alpha=0.2) +
    geom_point(data = test_0_CTL_with.df , aes(x=m, y = test_0_CTL_with), colour="#1A2C56") +
    geom_point(data = test_0_CTL_without.df , aes(x=m, y = test_0_CTL_without), colour="#D1A683") +
    xlab("Simulated migration rate")+ ylab("P-value binomial test for bias") + ggtitle("CTL") +
    theme(axis.text = element_text(size=18),axis.title = element_text(size=24), text = element_text(size=24),legend.position="bottom", 
          panel.grid.major =element_line(colour = "grey"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
          legend.key=element_blank(), legend.background = element_blank())+
    scale_y_continuous(trans = 'log10', limits = c(1e-6,1)) +
    scale_x_continuous( breaks = seq(0.001,0.01,0.001) ) + 
    scale_colour_manual("", values=c("Using True Genealogy" = "#1A2C56","Using sequence data" ="#D1A683"))
  
  p2_D <- ggplot() + 
    geom_rect(mapping=aes(xmin=0, xmax=0.01, ymin=1e-6, ymax=0.005, fill=TRUE), color=NA, fill='red', alpha=0.2) +
    geom_point(data = test_0_CTL_MFED_with.df , aes(x=m, y = test_0_CTL_MFED_with), colour="#1A2C56") +
    geom_point(data = test_0_CTL_MFED_without.df , aes(x=m, y = test_0_CTL_MFED_without), colour="#D1A683") +
    xlab("Simulated migration rate")+ ylab("P-value binomial test for bias") + ggtitle("CTL & MFED") +
    theme(axis.text = element_text(size=18),axis.title = element_text(size=24), text = element_text(size=24),legend.position="bottom", 
          panel.grid.major =element_line(colour = "grey"), panel.background = element_blank(), axis.line = element_line(colour = "black"),
          legend.key=element_blank(), legend.background = element_blank())+
    scale_y_continuous(trans = 'log10', limits = c(1e-6,1)) +
    scale_x_continuous( breaks = seq(0.001,0.01,0.001) ) + 
    scale_colour_manual("", values=c("Using True Genealogy" = "#1A2C56","Using sequence data" ="#D1A683"))
  
  return(list(p2_A, p2_B, p2_C, p2_D))
}
